import * as fs from 'node:fs/promises'
import * as path from 'node:path'
import type { StandardSchemaV1 } from '@standard-schema/spec'
import fm from 'front-matter'
import { glob } from 'glob'
import { format } from 'prettier'
import type { Plugin } from 'vite'
import { normalizePath } from 'vite'

interface FrontmatterExportConfig<Value = unknown> {
  inputDir: string
  output: {
    dir: string
    fileName: string
  }
  cwd?: string
  checkValue?: StandardSchemaV1<unknown, Value>
  transform?: (props: { frontmatter: Value; filePath: string }) => any
}

function frontmatterExportPlugin<Value = unknown>({
  inputDir,
  output,
  cwd = process.cwd(),
  checkValue,
  transform = ({ frontmatter, filePath: _ }) => frontmatter,
}: FrontmatterExportConfig<Value>): Plugin {
  async function generator() {
    await exportFrontmatters({
      inputDir,
      output,
      cwd,
      checkValue,
      transform,
    })
  }

  return {
    name: 'vite-plugin-frontmatter-export',
    async buildStart() {
      await generator()
    },
    async watchChange(file, type) {
      const inputPath = normalizePath(path.join(cwd, inputDir))
      if (
        file.includes(inputPath) &&
        isMarkdownFile(file) &&
        ['create', 'delete'].includes(type.event)
      ) {
        await generator()
      }
    },
    async handleHotUpdate({ file }) {
      const inputPath = normalizePath(path.join(cwd, inputDir))
      if (file.includes(inputPath) && isMarkdownFile(file)) {
        await generator()
      }
    },
  }
}

async function exportFrontmatters<Value = unknown>({
  inputDir,
  output: { dir: outputDir, fileName: outputFileName },
  cwd = process.cwd(),
  checkValue,
  transform = ({ frontmatter, filePath: _ }) => frontmatter,
}: FrontmatterExportConfig<Value>) {
  const outputPath = path.join(outputDir, outputFileName)
  const outputDirRelative = path.relative(cwd, outputDir)

  const filePaths = await findMarkdownFiles(inputDir)

  const frontmatters = await Promise.all(
    filePaths.map(async (filePath: string) => {
      const inputPath = path.join(inputDir, filePath)

      const content = await fs.readFile(inputPath, 'utf8')
      const frontmatterRaw = parseFrontmatter(content)
      const frontmatter = await validateWithSchema(frontmatterRaw, checkValue)
      const transformed = transform({
        frontmatter: frontmatter as Value,
        filePath,
      })

      return transformed
    }),
  )

  const serialized = await serializeFrontmatters(frontmatters)

  await fs.mkdir(outputDirRelative, { recursive: true })
  await writeIfChanged(outputPath, serialized)
}

function parseFrontmatter(content: string) {
  const { attributes: frontmatter } = fm(content)
  return frontmatter
}

async function validateWithSchema<T extends StandardSchemaV1>(
  input: StandardSchemaV1.InferInput<T>,
  schema?: T,
): Promise<StandardSchemaV1.InferOutput<T> | StandardSchemaV1.InferInput<T>> {
  if (!schema) return input

  let result = schema['~standard'].validate(input)
  if (result instanceof Promise) result = await result

  // if the `issues` field exists, the validation failed
  if (result.issues) {
    throw new Error(JSON.stringify(result.issues, null, 2))
  }

  return result.value
}

async function findMarkdownFiles(dir: string) {
  const filePaths = await glob('**/*.{md,mdx}', {
    cwd: dir,
  })
  // TODO: filesが存在しない場合に警告

  return filePaths
}

async function serializeFrontmatters(frontmatters: Array<any>) {
  const output = [
    `// This file is generated by scripts/get-frontmatter.ts`,
    ``,
    `export const frontmatters = [`,
    ...frontmatters.map((frontmatter) => `  ${JSON.stringify(frontmatter)},`),
    `]`,
    ``,
  ].join('\n')

  const formatted = await format(output, { parser: 'typescript' })

  return formatted
}

async function writeIfChanged(filepath: string, newContent: string) {
  try {
    const currentContent = await fs.readFile(filepath, 'utf8')
    if (currentContent !== newContent) {
      await fs.writeFile(filepath, newContent, 'utf8')
    }
  } catch {
    // File doesn't exist yet
    await fs.writeFile(filepath, newContent, 'utf8')
  }
}

function isMarkdownFile(filePath: string) {
  return filePath.endsWith('.md') || filePath.endsWith('.mdx')
}

export { frontmatterExportPlugin as frontmatterExport }
